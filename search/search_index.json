{
    "docs": [
        {
            "location": "/", 
            "text": "table tbody tr td:nth-child(2) {\n   color: limegreen;\n}\ntable tbody tr + tr  td:nth-child(2) {\n    color: orange;\n}\ntable tbody tr + tr + tr td:nth-child(2) {\n    color: tomato;\n}\n\n\n\n\n\nWelcome to the MPS Extensions\n\n\nThe MPS extensions aim to ease language development within MPS. They are maintained by itemis, JetBrains and the open source community and its development is closely related to the development of MPS.\n\n\nGetting Started\n\n\nTo get started grab a release from our release page on \ngithub\n. Extract the archive and point a project or global library in MPS to the location where you extracted it. \n\n\nSee the documentation regarding the individual extensions above. The documentation is \"currently work in progress\" as it being ported over from the mbeddr platform repository. Documentation related contributions are very welcome!\n\n\nWe are also working on providing a zip file with all the sandboxes we have in our repository in order to try things out and see how the extensions work. See this issue for \ndetails\n. \n\n\nArtefacts in the Nexus\n\n\nWe also provide the artefacts as a maven repository. Where you can fetch them during your CI build to setup your local development environment. \n\n\nMaven:\n\n\nproject ...\n\n    \nrepositories\n\n        \nrepository\n\n          \nid\nitemis.mbeddr\n/id\n\n          \nurl\nhttps://projects.itemis.de/nexus/content/repositories/mbeddr\n/url\n\n        \n/repository\n\n     \n/repositories\n\n\n     \ndependencies ...\n\n         \ndependency\n\n          \ngroupId\nde.itemis.mps\n/groupId\n\n          \nartifactId\nextensions\n/artifactId\n\n          \nversion\n2018.1\n/version\n\n          \ntype\nzip\n/type\n\n        \n/dependency\n\n    \n/dependencies\n\n\n/project\n\n\n\n\n\n\nGradle:\n\n\n    repositories {\n        maven { url 'https://projects.itemis.de/nexus/content/repositories/mbeddr' }\n    }\n\n    configurations {\n        mpsExtensions\n    }\n\n    dependencies {\n        mpsExtensions \nde.itemis.mps:extensions:2018.1.+\n\n    }\n\n\n\n\nVersions\n\n\nThe version number reflects the MPS version the extensions are compatible with. For instance \n2018.1.X\n is compatible with MPS 2018.1, \n2017.3.X\n is compatible with MPS 2017.3.6. We only maintain compatibility with the latest minor release for each major version. While a \n2017.3.x\n version of the extension might work with a on older version than MPS 2017.3.6 we only test it against the latest.    \n\n\nCurrent Versions\n\n\nCurrently these MPS versions are supported. Versions prior to MPS 2017.3 might still be available as the mbeddr platform but are not maintained in the repository.\n\n\nA version in maintenance will not get actively new features and is only maintained with bugfixes. We are happy to accept pull request for versions in maintenance with bugfixes but active feature development only happens for the latest MPS version.\n\n\n\n\n\n\n\n\nMPS Version\n\n\nState\n\n\n\n\n\n\n\n\n\n\n2018.1\n\n\nactive development\n\n\n\n\n\n\n2017.3\n\n\nmaintenance\n\n\n\n\n\n\n2017.2\n\n\nnot maintained\n\n\n\n\n\n\n2017.1\n\n\nnot maintained", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-the-mps-extensions", 
            "text": "The MPS extensions aim to ease language development within MPS. They are maintained by itemis, JetBrains and the open source community and its development is closely related to the development of MPS.", 
            "title": "Welcome to the MPS Extensions"
        }, 
        {
            "location": "/#getting-started", 
            "text": "To get started grab a release from our release page on  github . Extract the archive and point a project or global library in MPS to the location where you extracted it.   See the documentation regarding the individual extensions above. The documentation is \"currently work in progress\" as it being ported over from the mbeddr platform repository. Documentation related contributions are very welcome!  We are also working on providing a zip file with all the sandboxes we have in our repository in order to try things out and see how the extensions work. See this issue for  details .", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#artefacts-in-the-nexus", 
            "text": "We also provide the artefacts as a maven repository. Where you can fetch them during your CI build to setup your local development environment.   Maven:  project ... \n     repositories \n         repository \n           id itemis.mbeddr /id \n           url https://projects.itemis.de/nexus/content/repositories/mbeddr /url \n         /repository \n      /repositories \n\n      dependencies ... \n          dependency \n           groupId de.itemis.mps /groupId \n           artifactId extensions /artifactId \n           version 2018.1 /version \n           type zip /type \n         /dependency \n     /dependencies  /project   Gradle:      repositories {\n        maven { url 'https://projects.itemis.de/nexus/content/repositories/mbeddr' }\n    }\n\n    configurations {\n        mpsExtensions\n    }\n\n    dependencies {\n        mpsExtensions  de.itemis.mps:extensions:2018.1.+ \n    }", 
            "title": "Artefacts in the Nexus"
        }, 
        {
            "location": "/#versions", 
            "text": "The version number reflects the MPS version the extensions are compatible with. For instance  2018.1.X  is compatible with MPS 2018.1,  2017.3.X  is compatible with MPS 2017.3.6. We only maintain compatibility with the latest minor release for each major version. While a  2017.3.x  version of the extension might work with a on older version than MPS 2017.3.6 we only test it against the latest.", 
            "title": "Versions"
        }, 
        {
            "location": "/#current-versions", 
            "text": "Currently these MPS versions are supported. Versions prior to MPS 2017.3 might still be available as the mbeddr platform but are not maintained in the repository.  A version in maintenance will not get actively new features and is only maintained with bugfixes. We are happy to accept pull request for versions in maintenance with bugfixes but active feature development only happens for the latest MPS version.     MPS Version  State      2018.1  active development    2017.3  maintenance    2017.2  not maintained    2017.1  not maintained", 
            "title": "Current Versions"
        }, 
        {
            "location": "/building/", 
            "text": "Building\n\n\nThe MPS extension are build using gradle. In order to build the source code all you need on the machine is a Java 8 JDK. Of course if you want to hack on the MPS extension you need MPS. The MPS version that is currently used is in our \nbuild.gradle\n file.\n\n\nIn order to build the project run:\n\n\n./gradlew # Mac and Linux\ngradlew.bat # Windows\n\n\n\n\nThis will fetch the required MPS version from the internet so you need to be online when first execute the build.\n\n\nThe default task does not run the test when building if you want to execute the tests then run: \n\n\n./gradlew run_tests # Mac and Linux\ngradlew.bat run_tests # Windows", 
            "title": "Building"
        }, 
        {
            "location": "/building/#building", 
            "text": "The MPS extension are build using gradle. In order to build the source code all you need on the machine is a Java 8 JDK. Of course if you want to hack on the MPS extension you need MPS. The MPS version that is currently used is in our  build.gradle  file.  In order to build the project run:  ./gradlew # Mac and Linux\ngradlew.bat # Windows  This will fetch the required MPS version from the internet so you need to be online when first execute the build.  The default task does not run the test when building if you want to execute the tests then run:   ./gradlew run_tests # Mac and Linux\ngradlew.bat run_tests # Windows", 
            "title": "Building"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n\n\nContributes are always welcome, no matter if it's additional documentation, a bugfix, a new feature to an existing extension or complete new extension that you are adding to the repository. \n\n\nIf you are looking for an easy first contribution have a look at \nthis\n list.\n\n\nCurrently one of the biggest tasks we are working on is migrating some of the extensions from the mbeddr platform to this repository. If you like to help have a look at this \npage\n.\n\n\nShould you not feel comfortable to start with a code contribution additions to our documentation are always very welcome. Our \ndocumentation\n is in this repository as well. You can have edit it in your browser right a way if you like.\n\n\nFor bugfixes, documentation and small new features you can open a pull request right away. Bigger features or new extensions should get some discussion in an issue just to make sure we are all on the same page about what is going to be done. If you are unsure what to do don't hesitate to open a issue and ask for help.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "Contributes are always welcome, no matter if it's additional documentation, a bugfix, a new feature to an existing extension or complete new extension that you are adding to the repository.   If you are looking for an easy first contribution have a look at  this  list.  Currently one of the biggest tasks we are working on is migrating some of the extensions from the mbeddr platform to this repository. If you like to help have a look at this  page .  Should you not feel comfortable to start with a code contribution additions to our documentation are always very welcome. Our  documentation  is in this repository as well. You can have edit it in your browser right a way if you like.  For bugfixes, documentation and small new features you can open a pull request right away. Bigger features or new extensions should get some discussion in an issue just to make sure we are all on the same page about what is going to be done. If you are unsure what to do don't hesitate to open a issue and ask for help.", 
            "title": "Contributing"
        }, 
        {
            "location": "/Migrating/", 
            "text": "Migrating an Extension from the mbeddr Platform\n\n\nThere are two different kinds of migrating a extension from the mbeddr platform to the MPS-Extensions:\n\n\n\n\nThe extension already exists as a separate plugin in the mbeddr platform \n\n\nThe extension is currently part of the big \ncom.mbeddr.mpsutil\n plugin\n\n\n\n\nA list of the first (easier) to migrate extension is \nhere\n.\n\n\nMigrating extension of that list is pretty straight forward:\n\n\nCheck the Dependencies\n\n\nFirst of all check if all dependencies are already migrated to this repository. If you not you can't migrate the extension. To do so open the \ncom.mbeddr.build\n \nproject\n in the mbeddr repository. Click the link in the issue that is related to the extension to select the corresponding plugin in the build script. \n\n\nYou will see something like this:\n\n\nidea plugin com.mbeddr.mpsutil.jung \n  name com.mbeddr.mpsutil.jung \n  short (folder) name com.mbeddr.mpsutil.jung \n  description \nno description\n \n  version ${mbeddr.version} \n  \n no vendor \n \n  content: \n    group.jung \n  dependencies: \n    jetbrains.mps.core \n  \n ... \n \n\n\n\n\nFirst of all check the \ndependencies\n section of the plugin if it contains plugins that start with \ncom.meddr\n then it still has dependencies and cannot be moved. Though you might want to move the plugin it depends. \ud83d\ude09\n\n\nMove the Files\n\n\nIf all dependencies are already part of the MPS-extensions we can start with migrating the extension. Follow the reference(s) in the content section. \ngroup.jung\n in this case:\n\n\nmps group group.jung \n  solution com.mbeddr.mpsutil.jung.pluginSolution \n    load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/solutions/pluginSolution/com.mbeddr.mpsutil.jung.pluginSolution.msd \n\n  language com.mbeddr.mpsutil.jung \n    load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/com.mbeddr.mpsutil.jung.mpl \n\n\n\n\nBoth of modules in the plugin are located under the \ncode/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung\n directory. \n\n\nThe first thing to do is create a folder in the MPS-extensions repository where we can place these files. This folder should be placed in under the \ncode\n directory of the MPS-Extensions repository. The naming convention is that it shall contain the last name of the \nnamespace\n. In this case \njung\n. \n\n\nAll the files from the mbeddr repository \ncode/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung\n are copied over to \ncode/jung/lanugages\n in the MPS-extensions repository.\n\n\nThe structure in the MPS-extensions repository slightly differs from the one in mbeddr. That requires an additional step. Some languages contain a dedicated \nsolutions\n folder next to the language. We don't use this kind of file layout in the MPS-extensions repository. In theses cases the file from \ncode/jung/lanugages/solutions\n need to get moved to \ncode/jung/solutions\n.\n\n\nSounds too complicated? Don't worry we will help you when sent the pull request to get it right.\n \ud83d\ude09\n\n\nAdding the Files to the Project\n\n\nThe files need to be part of the MPS project to show up in MPS. This is done by adding them to the project path:\n\n\n\n\nAnd then selecting the before copied files: \n\n\n\n\nThe files end up in no folder in the project by default. They should be placed in a virtual folder of the project matches subfolder in \ncode\n. In this case \njung\n:\n\n\n\n\n\n\nAfter this is done the last step that is missing is adding the plugin to the build.\n\n\nAdding it to the Build\n\n\nTo build plugin that was moved it needs to beb part of the build scripts. These scripts are located under the \nbuild\n folder of the project. The solution of interest is \nde.itemis.mps.extensions.build\n. And then the \nde.itemis.mps.extensions\n build project:\n\n\n\n\nThe first thing required is a group where all the implementation modules of the plugin are places. Tests are placed in a different script. The group is named similar to the mbeddr group name but the prefix is not \ncom.mbeddr.mpsutil\n but \nde.itemis.mps\n. In this case this results to \nde.itemis.mps.jung\n. This group then contains all the the solutions and languages of the plugin:\n\n\n\n\nAfter the group is created a \nidea plugin\n is required. This plugin references the group and should be placed right above the group in the build script. This is very important to keep the build script maintainable. \n\n\n\n\nThe final step is adding the plugin to the layout section of the build project. \n\n\n\n\nAfter adding the plugin to the layout it should be possible to build the model. But in most cases a error like this will be shown:\n\n\ncannot build relative path to `wstx-asl-3.2.6.jar': No such path in local layout\n-- -- was input node: [path] BuildSourceMacroRelativePath null[8622958246116067669] in de.itemis.mps.extensions.build@5_1\n-- was template node: r:54537613-52b5-40a8-b223-e87f0960b04f(jetbrains.mps.build.mps.generator.template.main@generator)/4743026300739052425\n\n\n\n\nThis error message means that some jar files that are used by the language or some solution are missing. The convention here is to create a \nlib\n folder in the plugin and include the required \njar\n files. These files are usually contained in a \nlib\n folder. \n\n\n\n\nSending the Pull Request\n\n\nTo verify that everything works correctly run:\n\n\n./gradlew test # mac OS / Linux\n\ngradlew.bat test # Windows\n\n\n\n\nThis command should finish successfully. After that please create pull request at out repository and label it with \nmigration\n\n\nIf something doesn't work out quite well or you are unsure what to do don't worry. You can still send the PR and somebody will guide you through the process.\n\n\nBonus\n\n\nIf you are really eager you can send a PR to the mbeddr platform repository that removed the plugin there.", 
            "title": "Migrating"
        }, 
        {
            "location": "/Migrating/#migrating-an-extension-from-the-mbeddr-platform", 
            "text": "There are two different kinds of migrating a extension from the mbeddr platform to the MPS-Extensions:   The extension already exists as a separate plugin in the mbeddr platform   The extension is currently part of the big  com.mbeddr.mpsutil  plugin   A list of the first (easier) to migrate extension is  here .  Migrating extension of that list is pretty straight forward:", 
            "title": "Migrating an Extension from the mbeddr Platform"
        }, 
        {
            "location": "/Migrating/#check-the-dependencies", 
            "text": "First of all check if all dependencies are already migrated to this repository. If you not you can't migrate the extension. To do so open the  com.mbeddr.build   project  in the mbeddr repository. Click the link in the issue that is related to the extension to select the corresponding plugin in the build script.   You will see something like this:  idea plugin com.mbeddr.mpsutil.jung \n  name com.mbeddr.mpsutil.jung \n  short (folder) name com.mbeddr.mpsutil.jung \n  description  no description  \n  version ${mbeddr.version} \n    no vendor   \n  content: \n    group.jung \n  dependencies: \n    jetbrains.mps.core \n    ...     First of all check the  dependencies  section of the plugin if it contains plugins that start with  com.meddr  then it still has dependencies and cannot be moved. Though you might want to move the plugin it depends. \ud83d\ude09", 
            "title": "Check the Dependencies"
        }, 
        {
            "location": "/Migrating/#move-the-files", 
            "text": "If all dependencies are already part of the MPS-extensions we can start with migrating the extension. Follow the reference(s) in the content section.  group.jung  in this case:  mps group group.jung \n  solution com.mbeddr.mpsutil.jung.pluginSolution \n    load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/solutions/pluginSolution/com.mbeddr.mpsutil.jung.pluginSolution.msd \n\n  language com.mbeddr.mpsutil.jung \n    load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/com.mbeddr.mpsutil.jung.mpl   Both of modules in the plugin are located under the  code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung  directory.   The first thing to do is create a folder in the MPS-extensions repository where we can place these files. This folder should be placed in under the  code  directory of the MPS-Extensions repository. The naming convention is that it shall contain the last name of the  namespace . In this case  jung .   All the files from the mbeddr repository  code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung  are copied over to  code/jung/lanugages  in the MPS-extensions repository.  The structure in the MPS-extensions repository slightly differs from the one in mbeddr. That requires an additional step. Some languages contain a dedicated  solutions  folder next to the language. We don't use this kind of file layout in the MPS-extensions repository. In theses cases the file from  code/jung/lanugages/solutions  need to get moved to  code/jung/solutions .  Sounds too complicated? Don't worry we will help you when sent the pull request to get it right.  \ud83d\ude09", 
            "title": "Move the Files"
        }, 
        {
            "location": "/Migrating/#adding-the-files-to-the-project", 
            "text": "The files need to be part of the MPS project to show up in MPS. This is done by adding them to the project path:   And then selecting the before copied files:    The files end up in no folder in the project by default. They should be placed in a virtual folder of the project matches subfolder in  code . In this case  jung :    After this is done the last step that is missing is adding the plugin to the build.", 
            "title": "Adding the Files to the Project"
        }, 
        {
            "location": "/Migrating/#adding-it-to-the-build", 
            "text": "To build plugin that was moved it needs to beb part of the build scripts. These scripts are located under the  build  folder of the project. The solution of interest is  de.itemis.mps.extensions.build . And then the  de.itemis.mps.extensions  build project:   The first thing required is a group where all the implementation modules of the plugin are places. Tests are placed in a different script. The group is named similar to the mbeddr group name but the prefix is not  com.mbeddr.mpsutil  but  de.itemis.mps . In this case this results to  de.itemis.mps.jung . This group then contains all the the solutions and languages of the plugin:   After the group is created a  idea plugin  is required. This plugin references the group and should be placed right above the group in the build script. This is very important to keep the build script maintainable.    The final step is adding the plugin to the layout section of the build project.    After adding the plugin to the layout it should be possible to build the model. But in most cases a error like this will be shown:  cannot build relative path to `wstx-asl-3.2.6.jar': No such path in local layout\n-- -- was input node: [path] BuildSourceMacroRelativePath null[8622958246116067669] in de.itemis.mps.extensions.build@5_1\n-- was template node: r:54537613-52b5-40a8-b223-e87f0960b04f(jetbrains.mps.build.mps.generator.template.main@generator)/4743026300739052425  This error message means that some jar files that are used by the language or some solution are missing. The convention here is to create a  lib  folder in the plugin and include the required  jar  files. These files are usually contained in a  lib  folder.", 
            "title": "Adding it to the Build"
        }, 
        {
            "location": "/Migrating/#sending-the-pull-request", 
            "text": "To verify that everything works correctly run:  ./gradlew test # mac OS / Linux\n\ngradlew.bat test # Windows  This command should finish successfully. After that please create pull request at out repository and label it with  migration  If something doesn't work out quite well or you are unsure what to do don't worry. You can still send the PR and somebody will guide you through the process.", 
            "title": "Sending the Pull Request"
        }, 
        {
            "location": "/Migrating/#bonus", 
            "text": "If you are really eager you can send a PR to the mbeddr platform repository that removed the plugin there.", 
            "title": "Bonus"
        }, 
        {
            "location": "/extensions/diagrams/", 
            "text": "Diagrams\n\n\nLanguage Namespace :\n \nde.slisson.mps.editor.diagram\n\n\nIf you have downloaded the recent mbeddr master branch, you will have noticed that, for example, component wiring and state machines can now be edited graphically. The screenshots below show examples of these two notations.\n\n\nThis screenshot shows a few interesting features: you can embed diagrams anywhere in \"text\", you can use different shapes (at this point drawn by custom Java code), you can use various line styles, the framework supports ports (i.e., connection endpoints on the boxes), inside boxes you can use arbitrary MPS text (or other) editors, and the system also supports edge and endpoint labels. Port labels are also supported, but they are only shown if the mouse is \"in the vicinity\" of the port to not clutter the diagram. Below is a second screenshot of a bigger diagram:\n\n\nThis one illustrates that the approach scales to reasonable sizes, shows that zooming is supported and also demonstrates the auto layouting capability. The graphical notation also integrates with things such as tooltips. Below is another example diagram that shows a different language:\n\n\nThe definition of a graphical editor is based on the same \"cell\" abstraction used in other MPS editors: the language for defining editors contains additional cells that are then rendered as a diagram (diagram, diagram.box, diagram.edge). Similar to tables, these abstractions for defining graphical editors rely on queries to make sure that the structure of the graphical editor does not have to directly correspond to the structure of the AST (for example, in terms of ownership). The language also supports hierarchical diagrams, for example, in state machines.\n\n\nTo see example code, check out InstanceConfiguration and Statemachine.\n\n\nThe diagram notation is relatively sophisticated and requires much more documentation than what we can provide right now on this page. More will follow later.", 
            "title": "Diagrams"
        }, 
        {
            "location": "/extensions/diagrams/#diagrams", 
            "text": "Language Namespace :   de.slisson.mps.editor.diagram  If you have downloaded the recent mbeddr master branch, you will have noticed that, for example, component wiring and state machines can now be edited graphically. The screenshots below show examples of these two notations.  This screenshot shows a few interesting features: you can embed diagrams anywhere in \"text\", you can use different shapes (at this point drawn by custom Java code), you can use various line styles, the framework supports ports (i.e., connection endpoints on the boxes), inside boxes you can use arbitrary MPS text (or other) editors, and the system also supports edge and endpoint labels. Port labels are also supported, but they are only shown if the mouse is \"in the vicinity\" of the port to not clutter the diagram. Below is a second screenshot of a bigger diagram:  This one illustrates that the approach scales to reasonable sizes, shows that zooming is supported and also demonstrates the auto layouting capability. The graphical notation also integrates with things such as tooltips. Below is another example diagram that shows a different language:  The definition of a graphical editor is based on the same \"cell\" abstraction used in other MPS editors: the language for defining editors contains additional cells that are then rendered as a diagram (diagram, diagram.box, diagram.edge). Similar to tables, these abstractions for defining graphical editors rely on queries to make sure that the structure of the graphical editor does not have to directly correspond to the structure of the AST (for example, in terms of ownership). The language also supports hierarchical diagrams, for example, in state machines.  To see example code, check out InstanceConfiguration and Statemachine.  The diagram notation is relatively sophisticated and requires much more documentation than what we can provide right now on this page. More will follow later.", 
            "title": "Diagrams"
        }, 
        {
            "location": "/extensions/node-versioning/", 
            "text": "Node Versioning\n\n\nLanguage Namespace :\n \nde.itemis.mps.nodeversioning\n\n\nThe node versioning extension gives support for storing different \nstates/versions\n of a node inside of the model. It is \nnot\n a replacement for version control systems like \ngit\n.\n\n\nAn example use case might be a model is used to describe an API and the users wants to detect changes between different releases of the API. This API has a version number that follows semVer associated with it. Now when users wants check what changes happened since the last release the information stored by this extension can be used to diff the current state against the last released one.\n\n\nThe scope of this extension is to provide a way to store the versions of a node and do change detection. It does intentionally not provide ways how to semantically reason about a change as this is highly domain specific. It might be used in conjunction with the \nnodecomparator\n to do structural diffs between versions.\n\n\nState: \nIncubating\n \n\n\nThis extension is currently incubating and might under go substantial changes in the future. Currently it only supports storing of the version information and change detection. For future feature ideas see the \npotential features\n section.\n\n\nWhat is a \nNode\n\n\nWhen we speak of a node in this document we mean the node and \nall\n of its children but not of the referenced nodes. Sometimes this is also called \nsubtree\n.\n\n\nWhen we speak of the \ndependencies\n of a node we mean all nodes that are referenced by either node itself or it children. \n\n\nMeta Model\n\n\n\n\nThe version information is stored on the node that is versioned as a \nNodeAttribute\n called \nNodeVersion\n. The \nNodeVersion\n contains a copy of the node at point in time when the version was created. In addition to the copy it also stores a \nVersionNumber\n which is a simple integer incremented with each version that is created. The \nVersionNumber\n has no other semantics than to provide ordering to the versions. To be able to detect changes of a node it also stores a hash of the node. The \nNodeVersion\n also contains a list of all the dependencies (reference targets) of the node and its version, these are called \nLinkVersion\n. \n\n\nChange Detection\n\n\nOn first glance change detection looks pretty straight forward. A node has changed when either the node itself has changed or one of the dependencies:\n\n\n\n\nBut if we at MPS models they are not simple tree but graphs that allow reference cycles. In this cases we cannot simply traverse the complete graph over the edges since we would end up in a cycle. Imagine model like this:\n\n\n\n\nIn this case the change detection has to take into account that there is a cycle from \n5 --\n 4 --\n 6 --\n 5\n. The change detection algorithm detects this cycle and handles them appropriately. If none of the participants in a cycle have local changes then the whole cycle is assumed to be unchanged.\n\n\nTechnically the detection if a node has changed since the last time it has been versioned is done via hashing. If the hash differs from the hash calculated for the last version then the node has changed. The current implementation uses SHA 1 hashes to verify if the node has changed. \n\n\nPotential Features\n\n\n\n\ntime travel\n: Getting the model back into the exact same state as it was when a specific version on a node was created. Most likely as some kind of \ntransient\n model that is not visible to the user. \n\n\nReferencing nodes in a specific version. While this to some degree already happens behind the scenes. It might be useful for the user to implement an API in specific version.\n\n\nDelete handling. At the moment when the user deletes a node that is still referenced from some other node in an older version (that is potentially not visible to the user) the model is in a broken state.\n\n\n\n\nUsage\n\n\nThe general pattern that all functionally of the \nnodeversioning\n extension that all parts follow is that it will \nnever\n mutate the model during its execution. It will collect changes or calculate a new set of \nNodeVersions\n but its up to the user of the extension to actually mutate the model. This behaviour is due to the fact that the domain requires human interaction to review the changes and allow to veto based on that review. \n\n\nFirst of all models that should get versioned need to use the \nde.itemis.mps.nodeversioning\n language. Most probably you want to expose this to the end user through a DevKit. This language does not add anything the user can see or interact with but adds the \nNodeAttribute\ns required for the versioning.\n\n\nIn order to version a model or otherwise interact with the versions stored in the nodes use the \nde.itemis.mps.nodeversioning.runtime\n solution. The class you want to have a look at is \nVersioningHelper\n it provides the methods to version a node or check if something has changed. For more details see the JavaDoc on that class.", 
            "title": "Node Versioning"
        }, 
        {
            "location": "/extensions/node-versioning/#node-versioning", 
            "text": "Language Namespace :   de.itemis.mps.nodeversioning  The node versioning extension gives support for storing different  states/versions  of a node inside of the model. It is  not  a replacement for version control systems like  git .  An example use case might be a model is used to describe an API and the users wants to detect changes between different releases of the API. This API has a version number that follows semVer associated with it. Now when users wants check what changes happened since the last release the information stored by this extension can be used to diff the current state against the last released one.  The scope of this extension is to provide a way to store the versions of a node and do change detection. It does intentionally not provide ways how to semantically reason about a change as this is highly domain specific. It might be used in conjunction with the  nodecomparator  to do structural diffs between versions.  State:  Incubating    This extension is currently incubating and might under go substantial changes in the future. Currently it only supports storing of the version information and change detection. For future feature ideas see the  potential features  section.", 
            "title": "Node Versioning"
        }, 
        {
            "location": "/extensions/node-versioning/#what-is-a-node", 
            "text": "When we speak of a node in this document we mean the node and  all  of its children but not of the referenced nodes. Sometimes this is also called  subtree .  When we speak of the  dependencies  of a node we mean all nodes that are referenced by either node itself or it children.", 
            "title": "What is a Node"
        }, 
        {
            "location": "/extensions/node-versioning/#meta-model", 
            "text": "The version information is stored on the node that is versioned as a  NodeAttribute  called  NodeVersion . The  NodeVersion  contains a copy of the node at point in time when the version was created. In addition to the copy it also stores a  VersionNumber  which is a simple integer incremented with each version that is created. The  VersionNumber  has no other semantics than to provide ordering to the versions. To be able to detect changes of a node it also stores a hash of the node. The  NodeVersion  also contains a list of all the dependencies (reference targets) of the node and its version, these are called  LinkVersion .", 
            "title": "Meta Model"
        }, 
        {
            "location": "/extensions/node-versioning/#change-detection", 
            "text": "On first glance change detection looks pretty straight forward. A node has changed when either the node itself has changed or one of the dependencies:   But if we at MPS models they are not simple tree but graphs that allow reference cycles. In this cases we cannot simply traverse the complete graph over the edges since we would end up in a cycle. Imagine model like this:   In this case the change detection has to take into account that there is a cycle from  5 --  4 --  6 --  5 . The change detection algorithm detects this cycle and handles them appropriately. If none of the participants in a cycle have local changes then the whole cycle is assumed to be unchanged.  Technically the detection if a node has changed since the last time it has been versioned is done via hashing. If the hash differs from the hash calculated for the last version then the node has changed. The current implementation uses SHA 1 hashes to verify if the node has changed.", 
            "title": "Change Detection"
        }, 
        {
            "location": "/extensions/node-versioning/#potential-features", 
            "text": "time travel : Getting the model back into the exact same state as it was when a specific version on a node was created. Most likely as some kind of  transient  model that is not visible to the user.   Referencing nodes in a specific version. While this to some degree already happens behind the scenes. It might be useful for the user to implement an API in specific version.  Delete handling. At the moment when the user deletes a node that is still referenced from some other node in an older version (that is potentially not visible to the user) the model is in a broken state.", 
            "title": "Potential Features"
        }, 
        {
            "location": "/extensions/node-versioning/#usage", 
            "text": "The general pattern that all functionally of the  nodeversioning  extension that all parts follow is that it will  never  mutate the model during its execution. It will collect changes or calculate a new set of  NodeVersions  but its up to the user of the extension to actually mutate the model. This behaviour is due to the fact that the domain requires human interaction to review the changes and allow to veto based on that review.   First of all models that should get versioned need to use the  de.itemis.mps.nodeversioning  language. Most probably you want to expose this to the end user through a DevKit. This language does not add anything the user can see or interact with but adds the  NodeAttribute s required for the versioning.  In order to version a model or otherwise interact with the versions stored in the nodes use the  de.itemis.mps.nodeversioning.runtime  solution. The class you want to have a look at is  VersioningHelper  it provides the methods to version a node or check if something has changed. For more details see the JavaDoc on that class.", 
            "title": "Usage"
        }
    ]
}